//
// Created by ivelascog on 13/04/18.
//

#ifndef SKELGENERATOR_NEURON_H
#define SKELGENERATOR_NEURON_H

#include <skelgenerator/api.h>

#include <set>
#include <QThreadPool>
#include "VRMLReader.h"
#include "SamplePoint.h"
#include "Dendrite.h"
#include "Types.h"
#include "Spine.h"
#include "Mesh.h"

namespace skelgenerator {
    /** Internally the class have Fragments in Section class until the skeleton is finished procesing.
     *  Once the skeleton is processed it only contains sections.
    **/

    /// This class allow to generate a tracing from the 3D information contained in VRML files exported by Imaris Filament Tracer.
    /// There are a number of restrictions to consider: The apical dendrite and basal dendrite will be provided separately; the first point of all dendrites must be its closest point to the soma.
    /// For more information see the tutorial or the paper Neuronize V2 section 2.2 .
    class SKELGENERATOR_API Neuron {
        std::string _apiFile, _imarisFile;
        std::vector<std::string> _basalFiles;
        std::string _somaFile;
        std::vector<Section> _apiFragments;
        spineSet _apiSpines;
        std::vector<std::vector<Section>> _basalsFragments;
        std::vector<spineSet> _basalsSpines;
        int _segmentCounter;
        SamplePoint _soma;
        Mesh* _somaMesh;
        Dendrite* _apical;
        std::vector<Dendrite *> _basals;
        float _connectionThreshold;
        int _reamingSegments;
        int _reamingSpines;
        int _numDendrites;
        spineSet _spines;
        std::vector<TSpineImaris> _imarisSpines;
        std::vector<std::vector<SamplePoint>> _longsSpines;
        QThreadPool _pool;



    private:
        bool incorrectConecctions;
    public:
        struct OOBB {
            Eigen::Vector3d center;
            Eigen::Vector3d a0,a1,a2;
            double d0,d1,d2;
        };

        /// Constructor that load all the data and do a first attempt of conversion
        /// \param apiFile_ path to the input api dendrite
        /// \param basalFiles_ set of input files that contains basal dendrites. Each file must be contain at least a complete basal dendrite.
        /// \param somaFile_ path to the input soma mesh (obj format), this information are included to tracing in form of multiple 2D contours (only if export to ASC)
        /// \param imarisFile_ path to file that contains Imaris spines meshes (VRML format). This spines cannot be added to the tracing, but can export the meshes.
        /// \param longsFile_ path to file that contains a set of polylines that represents the trajectories of spines (generated by Imaris). The first point must be a head of the spine and the final point the insertion point.
        /// \param connectionThreshold_ Lets you control how far two fragments can be found to connect.
        Neuron( const std::string& apiFile_,
                const std::vector<std::string>& basalFiles_,
                const std::string& somaFile_ = "", const std::string& imarisFile_ = "",
                const std::string& longsFile_ = "", float connectionThreshold_ = 3 );

        /// Allows to recompute the tracing with another \p connectionThreshold in case that are interconnect fragments or spines. Note that the previous tracing are deleted.
        void reComputeSkel(float connectionThreshold);

        virtual ~Neuron();

        void addSpinesLongs (const std::string& longsFile_);
        void addImarisSpines( const std::string& imarisFile_);
        void addSoma(const std::string& somaFile_);
        void clearImarisSpines();
        std::string to_asc();

        /// export the generate tracing to ASC format and allows to add a 2D contours based soma
        /// \param contours Multiple contours that make up the soma. Note that, each contour must define a polyline without intersections.
        /// \param offset applied to all contours for cases where the contours and the neuron are not at the same coordinates.
        /// \return return the file in a string
        std::string to_asc(const std::vector<std::vector<Eigen::Vector3f>>& contours,const Eigen::Vector3f& displacement = {0,0,0});

        std::string to_swc(bool spines = false);

        /// export the spines (Filament Tracer) with the insertion sphere
        void spines_to_obj_with_base(std::string dirPath);

        /// export the spines (Filament Tracer) without the insertion sphere
        void spines_to_obj_without_base(std::string dirPath);
        void imarisSpinesToObj(std::string dirPath);
        bool isIncorrectConecctions() const;

        /// Return the number of unconnected fragments
        int getReamingSegments() const;

        /// Return the number of unconnected spines
        int getReamingSpines() const;

        const std::vector<TSpineImaris> &getImarisSpines() const;

        const std::string &getApiFile() const;

        const std::string &getImarisFile() const;

        const std::vector<std::string> &getBasalFiles() const;

        bool hasImarisSpines() const;

        bool hasFilamentSpines() const;

        const spineSet &getSpines() const;

        bool hasSomaMesh() const;

        void exportSomaMesh(const std::string& filePath);

    private:

      static Neuron::OOBB getBB(const TFragment& fragment);

      static bool collide(const Neuron::OOBB& BB1, const OOBB &BB2);

      std::vector<Section> generateFragments(TDendrite dendrite);

      Section getFragment(const TFragment &fragment);


      SubDendrite* computeSubDendrite(Section fragment, int initPoint,std::set<Section>& reamingFragments);


        std::tuple<SubDendrite *, int> computeDendrite(std::vector<Section> fragments);


        void procesSkel(float connectionThreshold);

        void generateSoma();

        void procesSpinesFilament();

        static spineSet generateSpines(const TDendrite &dendrite);

        void addSpines(Dendrite *dendrite, spineSet &spines);

        static std::tuple<Section *, int, float> getPosSpine(SubDendrite *subDendrite, const std::shared_ptr<Spine>& spine);

        void removeDuplicates(float threshold = 0.5f);

        void procesSpinesLongs();

        static void removeFragments(TDendrite& dendrite);

        static bool checkPointsInsideBB(const OOBB& oobb, const TFragment& fragment);

        static void exportFragmentAndBB(const OOBB &oobb, const TFragment &fragment, const std::string& prefixName);

        void improveInitialFragments();

        void forceTwoInitPoints();

        static bool checkPointsInsideMesh(const TFragment &cfragment, const TFragment &ifragment);

      void generateSomaMesh( );
    };
}


#endif //SKELGENERATOR_NEURON_H
